<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulazione Criteri di Congruenza</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #f1f5f9; touch-action: none; }
        canvas { 
            touch-action: none; 
            background: #ffffff; 
            cursor: default;
        }
        .active-tab { border-bottom: 4px solid #4f46e5; color: #4f46e5; }
        select {
            background-color: white;
            border: 1px solid #cbd5e1;
            border-radius: 4px;
            padding: 2px 4px;
            font-size: 0.7rem;
            cursor: pointer;
            max-width: 90px;
        }
    </style>
</head>
<body class="flex flex-col items-center min-h-screen p-2 md:p-6 font-sans">
    <a href="https://lbomben.github.io">Homepage</a>

    
    <div class="max-w-6xl w-full bg-white rounded-2xl shadow-xl overflow-hidden flex flex-col">
        <!-- Header -->
        <div class="bg-slate-800 p-6 text-white text-center">
            <h1 id="mainTitle" class="text-2xl md:text-3xl font-extrabold mb-2">Primo Criterio (LAL)</h1>
            <p id="mainDesc" class="text-slate-300 text-sm md:text-base max-w-2xl mx-auto italic text-balance">
                "Due triangoli sono congruenti se hanno uguali due lati e l'angolo tra essi compreso."
            </p>
        </div>

        <!-- Selettore ModalitÃ  -->
        <div class="flex border-b border-slate-200 overflow-x-auto bg-slate-50">
            <button id="tabLAL" class="flex-1 min-w-[90px] py-4 font-bold text-xs uppercase tracking-wider active-tab">LAL</button>
            <button id="tabALA" class="flex-1 min-w-[90px] py-4 font-bold text-xs uppercase tracking-wider text-slate-500 hover:text-indigo-600 transition-colors">ALA</button>
            <button id="tabLLL" class="flex-1 min-w-[90px] py-4 font-bold text-xs uppercase tracking-wider text-slate-500 hover:text-indigo-600 transition-colors">LLL</button>
            <button id="tabFREE" class="flex-1 min-w-[90px] py-4 font-bold text-xs uppercase tracking-wider text-slate-500 hover:text-indigo-600 transition-colors bg-amber-50/50">Libera âœ¨</button>
        </div>

        <!-- Pannello Info / Configurazione -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-px bg-slate-200 border-b border-slate-200">
            <div class="p-4 bg-blue-50/50 flex flex-col items-center">
                <span class="text-blue-700 font-bold text-xs uppercase tracking-widest mb-3 text-center">Triangolo ABC (Riferimento)</span>
                <div id="stats1" class="text-slate-700 font-mono text-[11px] space-y-1 w-full text-center"></div>
            </div>
            <div class="p-4 bg-rose-50/50 flex flex-col items-center border-t md:border-t-0 md:border-l border-slate-200">
                <span class="text-rose-700 font-bold text-xs uppercase tracking-widest mb-3 text-center">Triangolo DEF (Configurazione)</span>
                <div id="stats2" class="text-slate-700 font-mono text-[11px] space-y-2 w-full max-w-md"></div>
            </div>
        </div>

        <!-- Area Canvas -->
        <div class="relative w-full bg-slate-100 flex items-center justify-center p-2 md:p-4 overflow-hidden">
            <canvas id="geoCanvas" width="800" height="450" class="rounded-lg shadow-inner border border-slate-200 w-full h-auto max-w-full"></canvas>
            
            <div id="tutorial" class="absolute bottom-6 left-6 bg-black/70 text-white px-4 py-2 rounded-full text-xs pointer-events-none transition-opacity duration-500">
                ðŸ’¡ Trascina i vertici di ABC. Verifica la congruenza con il tasto in basso.
            </div>
        </div>

        <!-- Bottoni -->
        <div class="p-6 bg-white flex flex-col sm:flex-row gap-4 justify-center items-center">
            <button id="overlapBtn" class="w-full sm:w-auto px-10 py-3 bg-indigo-600 text-white rounded-xl font-bold hover:bg-indigo-700 transition-all shadow-lg active:scale-95">
                Verifica Sovrapposizione
            </button>
            <button id="resetBtn" class="w-full sm:w-auto px-10 py-3 bg-slate-200 text-slate-700 rounded-xl font-bold hover:bg-slate-300 transition-all">
                Cambia Orientamento
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('geoCanvas');
        const ctx = canvas.getContext('2d');
        const stats1 = document.getElementById('stats1');
        const stats2 = document.getElementById('stats2');
        const overlapBtn = document.getElementById('overlapBtn');
        const resetBtn = document.getElementById('resetBtn');
        
        const tabs = {
            LAL: document.getElementById('tabLAL'),
            ALA: document.getElementById('tabALA'),
            LLL: document.getElementById('tabLLL'),
            FREE: document.getElementById('tabFREE')
        };
        const mainTitle = document.getElementById('mainTitle');
        const mainDesc = document.getElementById('mainDesc');

        let mode = 'LAL'; 
        let pA, pB, pC;
        let redTriangleRotationOffset = 0; 
        const OFFSET_X = 380;
        let overlapFactor = 0; 
        let isAnimating = false;
        let activePoint = null;

        let mapping = {
            sideDE: 'sideAB',
            sideDF: 'sideAC',
            sideEF: 'free',
            angleD: 'angleA',
            angleE: 'free',
            angleF: 'free'
        };

        function initPoints() {
            pA = { x: 120, y: 320 };
            pB = { x: 320, y: 320 };
            pC = { x: 160, y: 150 };
            overlapFactor = 0;
            redTriangleRotationOffset = (Math.random() - 0.5) * Math.PI / 1.5;
            overlapBtn.innerText = "Verifica Sovrapposizione";
            draw();
        }

        function getDistance(p1, p2) {
            return Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
        }

        function getAngle(pCenter, p1, p2) {
            const a1 = Math.atan2(p1.y - pCenter.y, p1.x - pCenter.x);
            const a2 = Math.atan2(p2.y - pCenter.y, p2.x - pCenter.x);
            let angle = a2 - a1;
            while (angle <= -Math.PI) angle += Math.PI * 2;
            while (angle > Math.PI) angle -= Math.PI * 2;
            return angle;
        }

        function drawTick(p1, p2, color, count = 1) {
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x) + Math.PI/2;
            const len = 8;
            const gap = 4;
            ctx.strokeStyle = color; ctx.lineWidth = 2;
            for(let i = 0; i < count; i++) {
                const shift = (i - (count-1)/2) * gap;
                const ox = Math.cos(angle-Math.PI/2) * shift;
                const oy = Math.sin(angle-Math.PI/2) * shift;
                ctx.beginPath();
                ctx.moveTo(midX + ox + Math.cos(angle) * len, midY + oy + Math.sin(angle) * len);
                ctx.lineTo(midX + ox - Math.cos(angle) * len, midY + oy - Math.sin(angle) * len);
                ctx.stroke();
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const dAB = getDistance(pA, pB);
            const dAC = getDistance(pA, pC);
            const dBC = getDistance(pB, pC);
            const angA = getAngle(pA, pB, pC);
            const angB = getAngle(pB, pC, pA);
            const angC = getAngle(pC, pA, pB);

            const abcData = {
                sideAB: dAB, sideAC: dAC, sideBC: dBC,
                angleA: angA, angleB: angB, angleC: angC
            };

            // Calcolo posizione Triangolo DEF
            const currentRot = (Math.atan2(pB.y - pA.y, pB.x - pA.x)) + (redTriangleRotationOffset * (1 - overlapFactor));
            const curOffsetX = OFFSET_X * (1 - overlapFactor);
            const curD = { x: pA.x + curOffsetX, y: pA.y };

            let curE, curF;

            if (mode === 'LAL') {
                curE = { x: curD.x + dAB * Math.cos(currentRot), y: curD.y + dAB * Math.sin(currentRot) };
                curF = { x: curD.x + dAC * Math.cos(currentRot + angA), y: curD.y + dAC * Math.sin(currentRot + angA) };
            } else if (mode === 'ALA') {
                curE = { x: curD.x + dAB * Math.cos(currentRot), y: curD.y + dAB * Math.sin(currentRot) };
                // Intersezione semirette da D ed E
                const alpha = angA;
                const beta = -angB; // Segno opposto perchÃ© ruotiamo dall'altro lato del segmento
                const gamma = Math.PI - Math.abs(alpha) - Math.abs(beta);
                const distDF = (dAB * Math.sin(Math.abs(beta))) / Math.sin(gamma);
                curF = { x: curD.x + distDF * Math.cos(currentRot + alpha), y: curD.y + distDF * Math.sin(currentRot + alpha) };
            } else if (mode === 'LLL') {
                curE = { x: curD.x + dAB * Math.cos(currentRot), y: curD.y + dAB * Math.sin(currentRot) };
                // Usiamo Carnot per trovare l'angolo in D
                const cosD = (dAC**2 + dAB**2 - dBC**2) / (2 * dAC * dAB);
                const angleD = Math.acos(Math.max(-1, Math.min(1, cosD))) * Math.sign(angA);
                curF = { x: curD.x + dAC * Math.cos(currentRot + angleD), y: curD.y + dAC * Math.sin(currentRot + angleD) };
            } else {
                // ModalitÃ  Libera
                const baseLen = mapping.sideDE === 'free' ? 180 : abcData[mapping.sideDE];
                curE = { x: curD.x + baseLen * Math.cos(currentRot), y: curD.y + baseLen * Math.sin(currentRot) };
                
                const side2Len = mapping.sideDF === 'free' ? 140 : abcData[mapping.sideDF];
                const angleD = mapping.angleD === 'free' ? 0.8 : abcData[mapping.angleD];
                curF = { x: curD.x + side2Len * Math.cos(currentRot + angleD), y: curD.y + side2Len * Math.sin(currentRot + angleD) };
            }

            const actualDE = getDistance(curD, curE);
            const actualDF = getDistance(curD, curF);
            const actualEF = getDistance(curE, curF);
            const actualAngD = getAngle(curD, curE, curF);
            const actualAngE = getAngle(curE, curF, curD);
            const actualAngF = getAngle(curF, curD, curE);

            drawTriangle(pA, pB, pC, '#2563eb', ['A', 'B', 'C'], overlapFactor === 0, true);
            drawTriangle(curD, curE, curF, '#e11d48', ['D', 'E', 'F'], false, false);

            updateStats(abcData, {
                sideDE: actualDE, sideDF: actualDF, sideEF: actualEF,
                angleD: actualAngD, angleE: actualAngE, angleF: actualAngF
            });
        }

        function drawTriangle(p1, p2, p3, color, labels, canDrag, isMaster) {
            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.lineTo(p3.x, p3.y); ctx.closePath();
            ctx.fillStyle = color + '10'; ctx.fill();
            ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.stroke();

            const isConstrained = (type, id) => {
                if (mode === 'LAL') return (id === 'sideDE' || id === 'sideDF' || id === 'angleD');
                if (mode === 'ALA') return (id === 'sideDE' || id === 'angleD' || id === 'angleE');
                if (mode === 'LLL') return (type === 'side');
                return mapping[id] && mapping[id] !== 'free';
            };

            // Evidenzia elementi congruenti
            ctx.lineWidth = 4;
            if (isConstrained('side', 'sideDE')) { ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke(); drawTick(p1, p2, color, 1); }
            if (isConstrained('side', 'sideDF')) { ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p3.x, p3.y); ctx.stroke(); drawTick(p1, p3, color, 2); }
            if (isConstrained('side', 'sideEF')) { ctx.beginPath(); ctx.moveTo(p2.x, p2.y); ctx.lineTo(p3.x, p3.y); ctx.stroke(); drawTick(p2, p3, color, 3); }

            const drawArc = (p, pPrev, pNext, radius, isHyp) => {
                const a1 = Math.atan2(pPrev.y - p.y, pPrev.x - p.x);
                const a2 = Math.atan2(pNext.y - p.y, pNext.x - p.x);
                ctx.beginPath(); ctx.moveTo(p.x, p.y);
                ctx.arc(p.x, p.y, radius, a1, a2, (a2 - a1 + Math.PI * 4) % (Math.PI * 2) > Math.PI);
                ctx.fillStyle = color + (isHyp ? '40' : '10'); ctx.fill();
                ctx.strokeStyle = color; ctx.lineWidth = isHyp ? 3 : 1; ctx.stroke();
            };

            drawArc(p1, p2, p3, 30, isConstrained('angle', 'angleD'));
            drawArc(p2, p3, p1, 30, isConstrained('angle', 'angleE'));
            drawArc(p3, p1, p2, 30, isConstrained('angle', 'angleF'));

            [p1, p2, p3].forEach((p, i) => {
                ctx.beginPath(); ctx.arc(p.x, p.y, canDrag ? 10 : 4, 0, Math.PI * 2);
                ctx.fillStyle = canDrag ? 'white' : color; ctx.fill();
                ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.stroke();
                ctx.fillStyle = '#1e293b'; ctx.font = 'bold 14px sans-serif';
                ctx.fillText(labels[i], p.x - 5, p.y - 15);
            });
        }

        function updateStats(abc, def) {
            const u = (v) => (v/25).toFixed(1);
            const d = (a) => Math.abs(a * 180 / Math.PI).toFixed(1) + "Â°";
            
            stats1.innerHTML = `
                <div class="grid grid-cols-3 gap-1">
                    <span>AB: ${u(abc.sideAB)}</span><span>AC: ${u(abc.sideAC)}</span><span>BC: ${u(abc.sideBC)}</span>
                    <span>A: ${d(abc.angleA)}</span><span>B: ${d(abc.angleB)}</span><span>C: ${d(abc.angleC)}</span>
                </div>`;
            
            if (mode !== 'FREE') {
                stats2.innerHTML = `
                    <div class="grid grid-cols-3 gap-1 mt-1 font-bold">
                        <span>DE: ${u(def.sideDE)}</span><span>DF: ${u(def.sideDF)}</span><span>EF: ${u(def.sideEF)}</span>
                        <span>D: ${d(def.angleD)}</span><span>E: ${d(def.angleE)}</span><span>F: ${d(def.angleF)}</span>
                    </div>`;
            } else {
                const options = `
                    <option value="free">Libero</option>
                    <optgroup label="Lati ABC">
                        <option value="sideAB">Congr. AB</option>
                        <option value="sideAC">Congr. AC</option>
                        <option value="sideBC">Congr. BC</option>
                    </optgroup>
                    <optgroup label="Angoli ABC">
                        <option value="angleA">Congr. A</option>
                        <option value="angleB">Congr. B</option>
                        <option value="angleC">Congr. C</option>
                    </optgroup>`;

                const createRow = (label, key, val) => `
                    <div class="flex items-center justify-between gap-2 border-b border-rose-100 pb-1">
                        <span class="font-bold w-16">${label}: ${val}</span>
                        <select onchange="updateMapping('${key}', this.value)">
                            ${options.replace(`value="${mapping[key]}"`, `value="${mapping[key]}" selected`)}
                        </select>
                    </div>`;

                stats2.innerHTML = `
                    <div class="grid grid-cols-2 gap-x-4 gap-y-1">
                        ${createRow('DE', 'sideDE', u(def.sideDE))}
                        ${createRow('D', 'angleD', d(def.angleD))}
                        ${createRow('DF', 'sideDF', u(def.sideDF))}
                        ${createRow('E', 'angleE', d(def.angleE))}
                        ${createRow('EF', 'sideEF', u(def.sideEF))}
                        ${createRow('F', 'angleF', d(def.angleF))}
                    </div>`;
            }
        }

        window.updateMapping = (key, value) => { mapping[key] = value; draw(); };

        function getPos(e) {
            const r = canvas.getBoundingClientRect();
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: (cx - r.left) * (canvas.width / r.width), y: (cy - r.top) * (canvas.height / r.height) };
        }

        canvas.addEventListener('mousedown', (e) => {
            if (overlapFactor > 0) return;
            const m = getPos(e);
            [pA, pB, pC].forEach(p => { if (getDistance(m, p) < 30) activePoint = p; });
        });
        window.addEventListener('mousemove', (e) => {
            if (!activePoint) return;
            const m = getPos(e);
            activePoint.x = Math.max(20, Math.min(380, m.x));
            activePoint.y = Math.max(20, Math.min(430, m.y));
            draw();
        });
        window.addEventListener('mouseup', () => activePoint = null);

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            if (overlapFactor > 0) return;
            const m = getPos(e);
            [pA, pB, pC].forEach(p => { if (getDistance(m, p) < 40) activePoint = p; });
            if(activePoint) e.preventDefault();
        }, {passive: false});
        canvas.addEventListener('touchmove', (e) => {
            if (!activePoint) return;
            const m = getPos(e);
            activePoint.x = Math.max(20, Math.min(380, m.x));
            activePoint.y = Math.max(20, Math.min(430, m.y));
            draw();
            e.preventDefault();
        }, {passive: false});

        function switchTab(m) {
            mode = m;
            Object.keys(tabs).forEach(k => tabs[k].className = (k === m) ? "flex-1 min-w-[90px] py-4 font-bold text-xs uppercase tracking-wider active-tab" : "flex-1 min-w-[90px] py-4 font-bold text-xs uppercase tracking-wider text-slate-500 hover:text-indigo-600 transition-colors");
            if (m === 'LAL') { mainTitle.innerText = "Primo Criterio (LAL)"; mainDesc.innerText = '"Due triangoli sono congruenti se hanno uguali due lati e l\'angolo tra essi compreso."'; }
            else if (m === 'ALA') { mainTitle.innerText = "Secondo Criterio (ALA)"; mainDesc.innerText = '"Due triangoli sono congruenti se hanno uguali un lato e i due angoli ad esso adiacenti."'; }
            else if (m === 'LLL') { mainTitle.innerText = "Terzo Criterio (LLL)"; mainDesc.innerText = '"Due triangoli sono congruenti se hanno i tre lati rispettivamente uguali."'; }
            else { mainTitle.innerText = "Esplorazione Libera"; mainDesc.innerText = "Mappa ogni elemento di DEF su un elemento di ABC per testare configurazioni personalizzate."; }
            draw();
        }

        tabs.LAL.onclick = () => switchTab('LAL');
        tabs.ALA.onclick = () => switchTab('ALA');
        tabs.LLL.onclick = () => switchTab('LLL');
        tabs.FREE.onclick = () => switchTab('FREE');

        overlapBtn.onclick = () => {
            if (isAnimating) return;
            isAnimating = true;
            const start = overlapFactor, end = overlapFactor === 0 ? 1 : 0;
            const startTime = performance.now();
            const animate = (t) => {
                const p = Math.min((t - startTime) / 1000, 1);
                const ease = p < .5 ? 2*p*p : -1+(4-2*p)*p;
                overlapFactor = start + (end - start) * ease;
                draw();
                if (p < 1) requestAnimationFrame(animate);
                else { isAnimating = false; overlapBtn.innerText = end === 1 ? "Separa Triangoli" : "Verifica Sovrapposizione"; }
            };
            requestAnimationFrame(animate);
        };

        resetBtn.onclick = () => initPoints();
        window.onload = initPoints;
    </script>
</body>
</html>
