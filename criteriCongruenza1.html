<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulazione Criteri di Congruenza</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #f1f5f9; touch-action: none; }
        canvas { 
            touch-action: none; 
            background: #ffffff; 
            cursor: default;
        }
        .active-tab { border-bottom: 4px solid #4f46e5; color: #4f46e5; }
    </style>
</head>
<body class="flex flex-col items-center min-h-screen p-2 md:p-6 font-sans">
    <a href="https://lbomben.github.io" class="mb-4 text-indigo-600 hover:underline">Homepage</a>

    <div class="max-w-6xl w-full bg-white rounded-2xl shadow-xl overflow-hidden flex flex-col">
        <!-- Header -->
        <div class="bg-slate-800 p-6 text-white text-center">
            <h1 id="mainTitle" class="text-2xl md:text-3xl font-extrabold mb-2">Primo Criterio (LAL)</h1>
            <p id="mainDesc" class="text-slate-300 text-sm md:text-base max-w-2xl mx-auto italic text-balance">
                "Due triangoli sono congruenti se hanno uguali due lati e l'angolo tra essi compreso."
            </p>
        </div>

        <!-- Selettore ModalitÃ  -->
        <div class="flex border-b border-slate-200 overflow-x-auto bg-slate-50">
            <button id="tabLAL" class="flex-1 min-w-[90px] py-4 font-bold text-xs uppercase tracking-wider active-tab">LAL</button>
            <button id="tabALA" class="flex-1 min-w-[90px] py-4 font-bold text-xs uppercase tracking-wider text-slate-500 hover:text-indigo-600 transition-colors">ALA</button>
            <button id="tabLLL" class="flex-1 min-w-[90px] py-4 font-bold text-xs uppercase tracking-wider text-slate-500 hover:text-indigo-600 transition-colors">LLL</button>
            <button id="tabFREE" class="flex-1 min-w-[90px] py-4 font-bold text-xs uppercase tracking-wider text-slate-500 hover:text-indigo-600 transition-colors bg-amber-50/50">Libera âœ¨</button>
        </div>

        <!-- Pannello Info -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-px bg-slate-200 border-b border-slate-200">
            <div class="p-4 bg-blue-50/50 flex flex-col items-center">
                <span class="text-blue-700 font-bold text-xs uppercase tracking-widest mb-3 text-center">Triangolo ABC (Riferimento)</span>
                <div id="stats1" class="text-slate-700 font-mono text-[11px] space-y-1 w-full text-center"></div>
            </div>
            <div class="p-4 bg-rose-50/50 flex flex-col items-center border-t md:border-t-0 md:border-l border-slate-200">
                <span class="text-rose-700 font-bold text-xs uppercase tracking-widest mb-3 text-center">Triangolo DEF (Configurazione)</span>
                <div id="stats2" class="text-slate-700 font-mono text-[11px] space-y-2 w-full max-w-md text-center"></div>
            </div>
        </div>

        <!-- Area Canvas -->
        <div class="relative w-full bg-slate-100 flex items-center justify-center p-2 md:p-4 overflow-hidden">
            <canvas id="geoCanvas" width="800" height="450" class="rounded-lg shadow-inner border border-slate-200 w-full h-auto max-w-full"></canvas>
            
            <div id="tutorial" class="absolute bottom-6 left-6 bg-black/70 text-white px-4 py-2 rounded-full text-xs pointer-events-none transition-opacity duration-500">
                ðŸ’¡ Trascina i vertici. In modalitÃ  Libera puoi muovere entrambi i triangoli.
            </div>
        </div>

        <!-- Bottoni -->
        <div class="p-6 bg-white flex flex-col sm:flex-row gap-4 justify-center items-center">
            <button id="overlapBtn" class="w-full sm:w-auto px-10 py-3 bg-indigo-600 text-white rounded-xl font-bold hover:bg-indigo-700 transition-all shadow-lg active:scale-95">
                Verifica Sovrapposizione
            </button>
            <button id="resetBtn" class="w-full sm:w-auto px-10 py-3 bg-slate-200 text-slate-700 rounded-xl font-bold hover:bg-slate-300 transition-all">
                Cambia Orientamento
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('geoCanvas');
        const ctx = canvas.getContext('2d');
        const stats1 = document.getElementById('stats1');
        const stats2 = document.getElementById('stats2');
        const overlapBtn = document.getElementById('overlapBtn');
        const resetBtn = document.getElementById('resetBtn');
        
        const tabs = {
            LAL: document.getElementById('tabLAL'),
            ALA: document.getElementById('tabALA'),
            LLL: document.getElementById('tabLLL'),
            FREE: document.getElementById('tabFREE')
        };

        const mainTitle = document.getElementById('mainTitle');
        const mainDesc = document.getElementById('mainDesc');

        let mode = 'LAL'; 
        let pA, pB, pC; 
        let pD, pE, pF; 
        let rotationOffset = 0; 
        const INITIAL_OFFSET_X = 350;
        let overlapFactor = 0; 
        let isAnimating = false;
        let activePoint = null;
        let animationSnapshot = null;

        function initPoints() {
            pA = { x: 150, y: 320 };
            pB = { x: 300, y: 320 };
            pC = { x: 180, y: 180 };
            
            rotationOffset = (Math.random() - 0.5) * Math.PI / 1.5;
            
            // Inizializzazione DEF a una distanza iniziale
            pD = { x: pA.x + INITIAL_OFFSET_X, y: pA.y };
            updateDefFromAbc(); 
            
            draw();
        }

        function updateDefFromAbc() {
            if (mode === 'FREE') return;

            const vecAB = { x: pB.x - pA.x, y: pB.y - pA.y };
            const vecAC = { x: pC.x - pA.x, y: pC.y - pA.y };

            const rotate = (v, angle) => ({
                x: v.x * Math.cos(angle) - v.y * Math.sin(angle),
                y: v.x * Math.sin(angle) + v.y * Math.cos(angle)
            });

            const rotAB = rotate(vecAB, rotationOffset);
            const rotAC = rotate(vecAC, rotationOffset);

            pE = { x: pD.x + rotAB.x, y: pD.y + rotAB.y };
            pF = { x: pD.x + rotAC.x, y: pD.y + rotAC.y };
        }

        function getDistance(p1, p2) {
            return Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
        }

        function getAngle(pCenter, p1, p2) {
            const a1 = Math.atan2(p1.y - pCenter.y, p1.x - pCenter.x);
            const a2 = Math.atan2(p2.y - pCenter.y, p2.x - pCenter.x);
            let angle = a2 - a1;
            while (angle <= -Math.PI) angle += Math.PI * 2;
            while (angle > Math.PI) angle -= Math.PI * 2;
            return angle;
        }

        function drawTick(p1, p2, color, count = 1) {
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x) + Math.PI/2;
            const len = 8;
            const gap = 4;
            ctx.strokeStyle = color; ctx.lineWidth = 2;
            for(let i = 0; i < count; i++) {
                const shift = (i - (count-1)/2) * gap;
                const ox = Math.cos(angle-Math.PI/2) * shift;
                const oy = Math.sin(angle-Math.PI/2) * shift;
                ctx.beginPath();
                ctx.moveTo(midX + ox + Math.cos(angle) * len, midY + oy + Math.sin(angle) * len);
                ctx.lineTo(midX + ox - Math.cos(angle) * len, midY + oy - Math.sin(angle) * len);
                ctx.stroke();
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (mode !== 'FREE' && !isAnimating && overlapFactor === 0) {
                updateDefFromAbc();
            }

            let dD, dE, dF; 

            if (animationSnapshot) {
                const { start, target } = animationSnapshot;
                const lerp = (s, t, f) => s + (t - s) * f;
                dD = { x: lerp(start.D.x, target.D.x, overlapFactor), y: lerp(start.D.y, target.D.y, overlapFactor) };
                dE = { x: lerp(start.E.x, target.E.x, overlapFactor), y: lerp(start.E.y, target.E.y, overlapFactor) };
                dF = { x: lerp(start.F.x, target.F.x, overlapFactor), y: lerp(start.F.y, target.F.y, overlapFactor) };
            } else {
                dD = pD; dE = pE; dF = pF;
            }

            const abcData = {
                sideAB: getDistance(pA, pB), sideAC: getDistance(pA, pC), sideBC: getDistance(pB, pC),
                angleA: getAngle(pA, pB, pC), angleB: getAngle(pB, pC, pA), angleC: getAngle(pC, pA, pB)
            };

            const defData = {
                sideDE: getDistance(dD, dE), sideDF: getDistance(dD, dF), sideEF: getDistance(dE, dF),
                angleD: getAngle(dD, dE, dF), angleE: getAngle(dE, dF, dD), angleF: getAngle(dF, dD, dE)
            };

            drawTriangle(pA, pB, pC, '#2563eb', ['A', 'B', 'C'], overlapFactor === 0, true);
            drawTriangle(dD, dE, dF, '#e11d48', ['D', 'E', 'F'], (overlapFactor === 0), (mode === 'FREE'));

            updateStats(abcData, defData);
        }

        function drawTriangle(p1, p2, p3, color, labels, canDrag, isFreeOrDef) {
            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.lineTo(p3.x, p3.y); ctx.closePath();
            ctx.fillStyle = color + '15'; ctx.fill();
            ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.stroke();

            const isConstrained = (type, id) => {
                if (mode === 'FREE') return false;
                if (mode === 'LAL') return (id === 'sideDE' || id === 'sideDF' || id === 'angleD');
                if (mode === 'ALA') return (id === 'sideDE' || id === 'angleD' || id === 'angleE');
                if (mode === 'LLL') return (type === 'side');
                return false;
            };

            ctx.lineWidth = 4;
            if (isConstrained('side', 'sideDE')) { ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke(); drawTick(p1, p2, color, 1); }
            if (isConstrained('side', 'sideDF')) { ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p3.x, p3.y); ctx.stroke(); drawTick(p1, p3, color, 2); }
            if (isConstrained('side', 'sideEF')) { ctx.beginPath(); ctx.moveTo(p2.x, p2.y); ctx.lineTo(p3.x, p3.y); ctx.stroke(); drawTick(p2, p3, color, 3); }

            const drawArc = (p, pPrev, pNext, radius, isHyp) => {
                const a1 = Math.atan2(pPrev.y - p.y, pPrev.x - p.x);
                const a2 = Math.atan2(pNext.y - p.y, pNext.x - p.x);
                ctx.beginPath(); ctx.moveTo(p.x, p.y);
                ctx.arc(p.x, p.y, radius, a1, a2, (a2 - a1 + Math.PI * 4) % (Math.PI * 2) > Math.PI);
                ctx.fillStyle = color + (isHyp ? '45' : '15'); ctx.fill();
                ctx.strokeStyle = color; ctx.lineWidth = isHyp ? 3 : 1; ctx.stroke();
            };

            drawArc(p1, p2, p3, 30, isConstrained('angle', 'angleD'));
            drawArc(p2, p3, p1, 30, isConstrained('angle', 'angleE'));
            drawArc(p3, p1, p2, 30, isConstrained('angle', 'angleF'));

            [p1, p2, p3].forEach((p, i) => {
                const isD = (labels[i] === 'D');
                const dragEnabled = canDrag && (labels[0] === 'A' || mode === 'FREE' || (mode !== 'FREE' && isD));
                
                ctx.beginPath(); ctx.arc(p.x, p.y, dragEnabled ? 10 : 4, 0, Math.PI * 2);
                ctx.fillStyle = dragEnabled ? 'white' : color; ctx.fill();
                ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.stroke();
                ctx.fillStyle = '#1e293b'; ctx.font = 'bold 14px sans-serif';
                ctx.fillText(labels[i], p.x - 5, p.y - 15);
            });
        }

        function updateStats(abc, def) {
            const u = (v) => (v/25).toFixed(1);
            const d = (a) => Math.abs(a * 180 / Math.PI).toFixed(1) + "Â°";
            stats1.innerHTML = `<div class="grid grid-cols-3 gap-1"><span>AB: ${u(abc.sideAB)}</span><span>AC: ${u(abc.sideAC)}</span><span>BC: ${u(abc.sideBC)}</span><span>A: ${d(abc.angleA)}</span><span>B: ${d(abc.angleB)}</span><span>C: ${d(abc.angleC)}</span></div>`;
            stats2.innerHTML = `<div class="grid grid-cols-3 gap-1 mt-1 font-bold"><span>DE: ${u(def.sideDE)}</span><span>DF: ${u(def.sideDF)}</span><span>EF: ${u(def.sideEF)}</span><span>D: ${d(def.angleD)}</span><span>E: ${d(def.angleE)}</span><span>F: ${d(def.angleF)}</span></div>`;
        }

        function getPos(e) {
            const r = canvas.getBoundingClientRect();
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: (cx - r.left) * (canvas.width / r.width), y: (cy - r.top) * (canvas.height / r.height) };
        }

        canvas.onmousedown = (e) => {
            if (isAnimating || overlapFactor > 0) return;
            const m = getPos(e);
            const points = mode === 'FREE' ? [pA, pB, pC, pD, pE, pF] : [pA, pB, pC, pD];
            activePoint = points.find(p => getDistance(m, p) < 25);
        };

        window.onmousemove = (e) => {
            if (!activePoint) return;
            const m = getPos(e);
            activePoint.x = m.x; activePoint.y = m.y;
            draw();
        };

        window.onmouseup = () => activePoint = null;

        canvas.addEventListener('touchstart', (e) => {
            const m = getPos(e);
            const points = mode === 'FREE' ? [pA, pB, pC, pD, pE, pF] : [pA, pB, pC, pD];
            activePoint = points.find(p => getDistance(m, p) < 35);
            if (activePoint) e.preventDefault();
        }, {passive: false});

        canvas.addEventListener('touchmove', (e) => {
            if (!activePoint) return;
            const m = getPos(e);
            activePoint.x = m.x; activePoint.y = m.y;
            draw();
            e.preventDefault();
        }, {passive: false});

        function switchTab(m) {
            if (isAnimating) return;
            mode = m;
            Object.keys(tabs).forEach(k => tabs[k].className = (k === m) ? "flex-1 min-w-[90px] py-4 font-bold text-xs uppercase tracking-wider active-tab" : "flex-1 min-w-[90px] py-4 font-bold text-xs uppercase tracking-wider text-slate-500 hover:text-indigo-600 transition-colors");
            
            if (m === 'LAL') { mainTitle.innerText = "Primo Criterio (LAL)"; mainDesc.innerText = '"Due triangoli sono congruenti se hanno uguali due lati e l\'angolo tra essi compreso."'; }
            else if (m === 'ALA') { mainTitle.innerText = "Secondo Criterio (ALA)"; mainDesc.innerText = '"Due triangoli sono congruenti se hanno uguali un lato e i due angoli ad esso adiacenti."'; }
            else if (m === 'LLL') { mainTitle.innerText = "Terzo Criterio (LLL)"; mainDesc.innerText = '"Due triangoli sono congruenti se hanno i tre lati rispettivamente uguali."'; }
            else { mainTitle.innerText = "Esplorazione Libera âœ¨"; mainDesc.innerText = "Puoi manipolare indipendentemente entrambi i triangoli e tentare di sovrapporli."; }
            
            overlapFactor = 0;
            animationSnapshot = null;
            draw();
        }

        tabs.LAL.onclick = () => switchTab('LAL');
        tabs.ALA.onclick = () => switchTab('ALA');
        tabs.LLL.onclick = () => switchTab('LLL');
        tabs.FREE.onclick = () => switchTab('FREE');

        overlapBtn.onclick = () => {
            if (isAnimating) return;
            
            const isClosing = (overlapFactor === 0);

            // Se stiamo per chiudere, creiamo uno snapshot basato sulle posizioni attuali
            if (isClosing) {
                const start = { D: { ...pD }, E: { ...pE }, F: { ...pF } };
                const target = { D: { ...pA }, E: { ...pB }, F: { ...pC } };
                animationSnapshot = { start, target };
            }

            isAnimating = true;
            const startTime = performance.now();
            const duration = 800;

            const animate = (t) => {
                const elapsed = t - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const ease = progress < .5 ? 2*progress*progress : -1+(4-2*progress)*progress;
                
                overlapFactor = isClosing ? ease : 1 - ease;
                
                draw();
                
                if (progress < 1) requestAnimationFrame(animate);
                else { 
                    isAnimating = false;
                    if (!isClosing) {
                        // Quando si separa, ripristiniamo le coordinate iniziali dallo snapshot
                        pD = { ...animationSnapshot.start.D };
                        pE = { ...animationSnapshot.start.E };
                        pF = { ...animationSnapshot.start.F };
                        animationSnapshot = null;
                        overlapFactor = 0;
                        updateDefFromAbc(); // Riapplica vincoli se in modalitÃ  criteri
                    } else {
                        // Quando Ã¨ sovrapposto
                        pD = { ...pA }; pE = { ...pB }; pF = { ...pC };
                        overlapFactor = 1;
                    }
                    overlapBtn.innerText = isClosing ? "Separa Triangoli" : "Verifica Sovrapposizione";
                    draw();
                }
            };
            requestAnimationFrame(animate);
        };

        resetBtn.onclick = () => {
            if (isAnimating) return;
            rotationOffset = (Math.random() - 0.5) * Math.PI;
            overlapFactor = 0;
            animationSnapshot = null;
            updateDefFromAbc();
            draw();
        };

        window.onload = initPoints;
    </script>
</body>
</html>
