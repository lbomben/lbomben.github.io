<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Simulazione Criteri di Congruenza</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #f1f5f9; touch-action: none; overflow: hidden; }
        canvas { 
            touch-action: none; 
            background: #ffffff; 
            cursor: crosshair;
            image-rendering: -webkit-optimize-contrast;
        }
        .active-tab { border-bottom: 4px solid #4f46e5; color: #4f46e5; background: #fff; }
        .free-controls select { 
            font-size: 10px; 
            padding: 2px; 
            border-radius: 4px; 
            border: 1px solid #cbd5e1;
            background: white;
        }
    </style>
</head>
<body class="flex flex-col items-center min-h-screen p-2 md:p-4 font-sans">
    <a href="https://lbomben.github.io" class="mb-2 text-indigo-600 hover:underline text-sm">Homepage</a>

    <div class="max-w-5xl w-full bg-white rounded-xl shadow-2xl overflow-hidden flex flex-col border border-slate-200">
        <!-- Header -->
        <div class="bg-slate-900 p-4 text-white text-center">
            <h1 id="mainTitle" class="text-xl md:text-2xl font-bold">Primo Criterio (LAL)</h1>
            <p id="mainDesc" class="text-slate-400 text-xs md:text-sm italic">
                "Due triangoli sono congruenti se hanno uguali due lati e l'angolo tra essi compreso."
            </p>
        </div>

        <!-- Tabs -->
        <div class="flex border-b border-slate-200 bg-slate-50">
            <button id="tabLAL" class="flex-1 py-3 font-bold text-[10px] md:text-xs uppercase tracking-tighter active-tab">LAL</button>
            <button id="tabALA" class="flex-1 py-3 font-bold text-[10px] md:text-xs uppercase tracking-tighter text-slate-500">ALA</button>
            <button id="tabLLL" class="flex-1 py-3 font-bold text-[10px] md:text-xs uppercase tracking-tighter text-slate-500">LLL</button>
            <button id="tabFREE" class="flex-1 py-3 font-bold text-[10px] md:text-xs uppercase tracking-tighter text-amber-600 bg-amber-50/30">Libera ✨</button>
        </div>

        <!-- Pannello Controlli Modalità Libera -->
        <div id="freePanel" class="hidden bg-amber-50 border-b border-amber-100 p-2 grid grid-cols-2 md:grid-cols-4 gap-4 text-[10px] uppercase font-bold text-amber-900">
            <div class="flex flex-col gap-1">
                <span>Lato DE ≡</span>
                <select id="bindDE" class="bind-select"><option value="none">Libero</option><option value="AB">Lato AB</option></select>
                <span>Lato DF ≡</span>
                <select id="bindDF" class="bind-select"><option value="none">Libero</option><option value="AC">Lato AC</option></select>
            </div>
            <div class="flex flex-col gap-1">
                <span>Lato EF ≡</span>
                <select id="bindEF" class="bind-select"><option value="none">Libero</option><option value="BC">Lato BC</option></select>
                <span>Angolo D ≡</span>
                <select id="bindAD" class="bind-select"><option value="none">Libero</option><option value="A">Angolo A</option></select>
            </div>
            <div class="flex flex-col gap-1">
                <span>Angolo E ≡</span>
                <select id="bindAE" class="bind-select"><option value="none">Libero</option><option value="B">Angolo B</option></select>
                <span>Angolo F ≡</span>
                <select id="bindAF" class="bind-select"><option value="none">Libero</option><option value="C">Angolo C</option></select>
            </div>
            <div class="flex items-center justify-center">
                <button id="clearBindsBtn" class="w-full h-full bg-amber-200 hover:bg-amber-300 text-amber-900 rounded-md border border-amber-400 p-1 transition-colors">
                    Rimuovi tutti i vincoli
                </button>
            </div>
        </div>

        <!-- Dati Geometrici -->
        <div class="grid grid-cols-2 gap-px bg-slate-200 text-[10px] md:text-xs font-mono">
            <div class="p-2 bg-blue-50 text-blue-800 flex flex-col items-center">
                <span class="font-bold mb-1">TRIANGOLO ABC</span>
                <div id="stats1" class="text-center"></div>
            </div>
            <div class="p-2 bg-rose-50 text-rose-800 flex flex-col items-center">
                <span class="font-bold mb-1">TRIANGOLO DEF</span>
                <div id="stats2" class="text-center"></div>
            </div>
        </div>

        <!-- Canvas -->
        <div class="relative w-full bg-slate-100 p-1 flex justify-center items-center">
            <canvas id="geoCanvas" width="800" height="400" class="w-full h-auto max-w-full rounded shadow-inner"></canvas>
        </div>

        <!-- Controlli -->
        <div class="p-4 bg-white flex gap-2 justify-center border-t border-slate-100">
            <button id="overlapBtn" class="px-6 py-3 bg-indigo-600 text-white rounded-lg font-bold text-sm shadow-md active:scale-95 transition-all">
                Verifica Sovrapposizione
            </button>
            <button id="resetBtn" class="px-6 py-3 bg-slate-200 text-slate-700 rounded-lg font-bold text-sm hover:bg-slate-300 transition-all">
                Ruota DEF
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('geoCanvas');
        const ctx = canvas.getContext('2d');
        const overlapBtn = document.getElementById('overlapBtn');
        const resetBtn = document.getElementById('resetBtn');
        const clearBindsBtn = document.getElementById('clearBindsBtn');
        const stats1 = document.getElementById('stats1');
        const stats2 = document.getElementById('stats2');
        const freePanel = document.getElementById('freePanel');
        
        let pA, pB, pC; 
        let pD, pE, pF; 
        let mode = 'LAL';
        let rotation = Math.PI / 4;
        let overlapFactor = 0; 
        let isAnimating = false;
        let activePoint = null;
        let lastKnownDEF = null;

        const bindings = {
            DE: 'none', DF: 'none', EF: 'none',
            D: 'none', E: 'none', F: 'none'
        };

        function init() {
            pA = { x: 150, y: 300 };
            pB = { x: 300, y: 300 };
            pC = { x: 180, y: 150 };
            pD = { x: 500, y: 300 };
            pE = { x: 650, y: 300 };
            pF = { x: 530, y: 150 };

            ['DE', 'DF', 'EF'].forEach(id => {
                document.getElementById('bind' + id).onchange = (e) => {
                    bindings[id] = e.target.value;
                    draw();
                };
            });
            document.getElementById('bindAD').onchange = (e) => { bindings.D = e.target.value; draw(); };
            document.getElementById('bindAE').onchange = (e) => { bindings.E = e.target.value; draw(); };
            document.getElementById('bindAF').onchange = (e) => { bindings.F = e.target.value; draw(); };

            clearBindsBtn.onclick = () => {
                for (let key in bindings) {
                    bindings[key] = 'none';
                }
                document.querySelectorAll('.bind-select').forEach(select => {
                    select.value = 'none';
                });
                draw();
            };

            syncDEF();
            draw();
        }

        function syncDEF() {
            if (isAnimating || overlapFactor > 0) return;

            if (mode !== 'FREE') {
                const vAB = { x: pB.x - pA.x, y: pB.y - pA.y };
                const vAC = { x: pC.x - pA.x, y: pC.y - pA.y };
                const rot = (v, a) => ({
                    x: v.x * Math.cos(a) - v.y * Math.sin(a),
                    y: v.x * Math.sin(a) + v.y * Math.cos(a)
                });
                const rAB = rot(vAB, rotation);
                const rAC = rot(vAC, rotation);
                pE = { x: pD.x + rAB.x, y: pD.y + rAB.y };
                pF = { x: pD.x + rAC.x, y: pD.y + rAC.y };
                return;
            }

            const distAB = getDist(pA, pB);
            const distAC = getDist(pA, pC);
            const distBC = getDist(pB, pC);
            const angA = getRad(pA, pB, pC);
            const angB = getRad(pB, pA, pC);
            const angC = getRad(pC, pA, pB);
            const crossABC = (pB.x - pA.x) * (pC.y - pA.y) - (pB.y - pA.y) * (pC.x - pA.x);
            const sign = crossABC > 0 ? 1 : -1;

            if (bindings.DE === 'AB') {
                const angleAB = Math.atan2(pB.y - pA.y, pB.x - pA.x);
                pE.x = pD.x + Math.cos(angleAB) * distAB;
                pE.y = pD.y + Math.sin(angleAB) * distAB;
            }

            const angleDE = Math.atan2(pE.y - pD.y, pE.x - pD.x);

            if (bindings.D === 'A') {
                const targetAngF = angleDE + (sign * angA);
                const dDF = (bindings.DF === 'AC') ? distAC : getDist(pD, pF);
                pF.x = pD.x + Math.cos(targetAngF) * dDF;
                pF.y = pD.y + Math.sin(targetAngF) * dDF;
            } else if (bindings.E === 'B') {
                const targetAngF = (angleDE + Math.PI) - (sign * angB);
                const dEF = (bindings.EF === 'BC') ? distBC : getDist(pE, pF);
                pF.x = pE.x + Math.cos(targetAngF) * dEF;
                pF.y = pE.y + Math.sin(targetAngF) * dEF;
            }

            if (bindings.DF === 'AC' && bindings.D !== 'A') {
                const angDF = Math.atan2(pF.y - pD.y, pF.x - pD.x);
                pF.x = pD.x + Math.cos(angDF) * distAC;
                pF.y = pD.y + Math.sin(angDF) * distAC;
            }
            if (bindings.EF === 'BC' && bindings.E !== 'B') {
                const angEF = Math.atan2(pF.y - pE.y, pF.x - pE.x);
                pF.x = pE.x + Math.cos(angEF) * distBC;
                pF.y = pE.y + Math.sin(angEF) * distBC;
            }

            if (bindings.F === 'C') {
                const angFD_current = Math.atan2(pD.y - pF.y, pD.x - pF.x);
                const currentDistFE = getDist(pF, pE);
                const targetAngE = angFD_current + (sign * angC);
                pE.x = pF.x + Math.cos(targetAngE) * currentDistFE;
                pE.y = pF.y + Math.sin(targetAngE) * currentDistFE;
            }
        }

        function getDist(p1, p2) { return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2); }
        
        function getRad(pCenter, p1, p2) {
            const v1 = { x: p1.x - pCenter.x, y: p1.y - pCenter.y };
            const v2 = { x: p2.x - pCenter.x, y: p2.y - pCenter.y };
            const dot = v1.x * v2.x + v1.y * v2.y;
            const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
            const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
            return Math.acos(Math.max(-1, Math.min(1, dot / (mag1 * mag2))));
        }

        function getDeg(pCenter, p1, p2) {
            return getRad(pCenter, p1, p2) * 180 / Math.PI;
        }

        function drawSideMarker(p1, p2, color, count) {
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x) + Math.PI / 2;
            const len = 6;
            const gap = 3;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            for (let i = 0; i < count; i++) {
                const shift = (i - (count - 1) / 2) * gap;
                const offsetX = Math.cos(angle - Math.PI / 2) * shift;
                const offsetY = Math.sin(angle - Math.PI / 2) * shift;
                ctx.beginPath();
                ctx.moveTo(midX + offsetX + Math.cos(angle) * len, midY + offsetY + Math.sin(angle) * len);
                ctx.lineTo(midX + offsetX - Math.cos(angle) * len, midY + offsetY - Math.sin(angle) * len);
                ctx.stroke();
            }
        }

        function drawAngleMarker(p, p1, p2, color, isHighlighted) {
            const startAngle = Math.atan2(p1.y - p.y, p1.x - p.x);
            const endAngle = Math.atan2(p2.y - p.y, p2.x - p.x);
            const r = 25;
            const v1 = {x: p1.x - p.x, y: p1.y - p.y};
            const v2 = {x: p2.x - p.x, y: p2.y - p.y};
            const cross = v1.x * v2.y - v1.y * v2.x;
            
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.arc(p.x, p.y, r, startAngle, endAngle, cross < 0);
            ctx.closePath();
            ctx.fillStyle = color + (isHighlighted ? "40" : "10");
            ctx.fill();
            if (isHighlighted) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function drawTriangle(pts, color, labels, active) {
            const [p1, p2, p3] = pts;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.closePath();
            ctx.fillStyle = color + "15";
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.lineWidth = active ? 3 : 1;
            ctx.stroke();

            if (mode !== 'FREE') {
                const isLAL = mode === 'LAL';
                const isALA = mode === 'ALA';
                const isLLL = mode === 'LLL';
                if (isLAL || isALA || isLLL) drawSideMarker(p1, p2, color, 1);
                if (isLAL || isLLL) drawSideMarker(p1, p3, color, 2);
                if (isLLL) drawSideMarker(p2, p3, color, 3);
                drawAngleMarker(p1, p2, p3, color, isLAL || isALA);
                drawAngleMarker(p2, p3, p1, color, isALA);
            } else {
                if (bindings.DE === 'AB') drawSideMarker(p1, p2, color, 1);
                if (bindings.DF === 'AC') drawSideMarker(p1, p3, color, 2);
                if (bindings.EF === 'BC') drawSideMarker(p2, p3, color, 3);
                if (bindings.D === 'A') drawAngleMarker(p1, p2, p3, color, true);
                if (bindings.E === 'B') drawAngleMarker(p2, p3, p1, color, true);
                if (bindings.F === 'C') drawAngleMarker(p3, p1, p2, color, true);
            }

            pts.forEach((p, i) => {
                const isDraggable = active && (labels[i] === 'A' || labels[i] === 'D' || mode === 'FREE');
                ctx.beginPath();
                ctx.arc(p.x, p.y, isDraggable ? 6 : 4, 0, Math.PI * 2);
                ctx.fillStyle = isDraggable ? "white" : color;
                ctx.fill();
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = "#1e293b";
                ctx.font = "bold 12px sans-serif";
                ctx.fillText(labels[i], p.x - 5, p.y - 12);
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            syncDEF();

            let renderDEF;
            if (overlapFactor > 0) {
                const start = lastKnownDEF || { D: pD, E: pE, F: pF };
                const angABC = Math.atan2(pB.y - pA.y, pB.x - pA.x);
                const angDEF = Math.atan2(start.E.y - start.D.y, start.E.x - start.D.x);
                
                const lerp = (a, b, f) => a + (b - a) * f;
                const curDx = lerp(start.D.x, pA.x, overlapFactor);
                const curDy = lerp(start.D.y, pA.y, overlapFactor);
                const curRot = lerp(0, angABC - angDEF, overlapFactor);
                
                const rotatePoint = (p, center, angle) => {
                    const s = Math.sin(angle);
                    const c = Math.cos(angle);
                    const px = p.x - center.x;
                    const py = p.y - center.y;
                    return {
                        x: px * c - py * s + center.x,
                        y: px * s + py * c + center.y
                    };
                };

                const eRel = { x: start.E.x - start.D.x + curDx, y: start.E.y - start.D.y + curDy };
                const fRel = { x: start.F.x - start.D.x + curDx, y: start.F.y - start.D.y + curDy };
                const curE = rotatePoint(eRel, {x: curDx, y: curDy}, curRot);
                const curF = rotatePoint(fRel, {x: curDx, y: curDy}, curRot);

                renderDEF = [{x: curDx, y: curDy}, curE, curF];
            } else {
                renderDEF = [pD, pE, pF];
            }

            drawTriangle([pA, pB, pC], "#2563eb", ["A", "B", "C"], overlapFactor === 0);
            drawTriangle(renderDEF, "#e11d48", ["D", "E", "F"], overlapFactor === 0);

            const fmt = (n) => (n/20).toFixed(1);
            stats1.innerHTML = `AB:${fmt(getDist(pA,pB))} AC:${fmt(getDist(pA,pC))} | A:${getDeg(pA,pB,pC).toFixed(0)}°`;
            stats2.innerHTML = `DE:${fmt(getDist(renderDEF[0],renderDEF[1]))} DF:${fmt(getDist(renderDEF[0],renderDEF[2]))} | D:${getDeg(renderDEF[0],renderDEF[1],renderDEF[2]).toFixed(0)}°`;
        }

        function animateOverlap(target) {
            if (isAnimating) return;
            isAnimating = true;
            lastKnownDEF = { D: {...pD}, E: {...pE}, F: {...pF} };
            const duration = 800;
            const startTime = performance.now();
            const startVal = overlapFactor;
            function step(now) {
                const elapsed = now - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const ease = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                overlapFactor = startVal + (target - startVal) * ease;
                draw();
                if (progress < 1) requestAnimationFrame(step);
                else {
                    overlapFactor = target;
                    isAnimating = false;
                    if (overlapFactor === 0) lastKnownDEF = null;
                    overlapBtn.innerText = overlapFactor === 1 ? "Separa Triangoli" : "Verifica Sovrapposizione";
                    draw();
                }
            }
            requestAnimationFrame(step);
        }

        overlapBtn.onclick = () => animateOverlap(overlapFactor === 0 ? 1 : 0);
        
        resetBtn.onclick = () => {
            if (isAnimating || overlapFactor > 0) return;
            
            if (mode !== 'FREE') {
                rotation += 0.5;
            } else {
                // In modalità libera ruotiamo fisicamente i vertici E ed F attorno a D
                const distE = getDist(pD, pE);
                const distF = getDist(pD, pF);
                const angE = Math.atan2(pE.y - pD.y, pE.x - pD.x) + 0.5;
                const angF = Math.atan2(pF.y - pD.y, pF.x - pD.x) + 0.5;
                
                // Aggiorniamo i punti. syncDEF userà queste nuove posizioni come base
                pE.x = pD.x + Math.cos(angE) * distE;
                pE.y = pD.y + Math.sin(angE) * distE;
                pF.x = pD.x + Math.cos(angF) * distF;
                pF.y = pD.y + Math.sin(angF) * distF;
            }
            draw();
        };

        function handleStart(e) {
            if (isAnimating || overlapFactor > 0) return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            const mx = x * (canvas.width / rect.width);
            const my = y * (canvas.height / rect.height);
            const pts = [pA, pB, pC, pD, pE, pF];
            activePoint = pts.find(p => Math.hypot(p.x - mx, p.y - my) < 20);
        }

        function handleMove(e) {
            if (!activePoint) return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            activePoint.x = x * (canvas.width / rect.width);
            activePoint.y = y * (canvas.height / rect.height);
            draw();
        }

        canvas.onmousedown = handleStart;
        window.onmousemove = handleMove;
        window.onmouseup = () => activePoint = null;
        canvas.ontouchstart = (e) => { handleStart(e); e.preventDefault(); };
        canvas.ontouchmove = (e) => { handleMove(e); e.preventDefault(); };
        canvas.ontouchend = () => activePoint = null;

        function setMode(m, el) {
            mode = m;
            document.querySelectorAll('button').forEach(b => b.classList.remove('active-tab'));
            el.classList.add('active-tab');
            overlapFactor = 0;
            lastKnownDEF = null;
            
            if (m === 'FREE') {
                freePanel.classList.remove('hidden');
                mainTitle.innerText = "Esplorazione Libera";
                mainDesc.innerText = 'Definisci vincoli personalizzati e verifica la congruenza tramite sovrapposizione rigida.';
            } else {
                freePanel.classList.add('hidden');
                if(m==='LAL'){ mainTitle.innerText="Primo Criterio (LAL)"; mainDesc.innerText='"Due triangoli sono congruenti se hanno uguali due lati e l\'angolo tra essi compreso."'; }
                if(m==='ALA'){ mainTitle.innerText="Secondo Criterio (ALA)"; mainDesc.innerText='"Due triangoli sono congruenti se hanno uguali un lato e i due angoli ad esso adiacenti."'; }
                if(m==='LLL'){ mainTitle.innerText="Terzo Criterio (LLL)"; mainDesc.innerText='"Due triangoli sono congruenti se hanno i tre lati rispettivamente uguali."'; }
            }
            draw();
        }

        document.getElementById('tabLAL').onclick = (e) => setMode('LAL', e.target);
        document.getElementById('tabALA').onclick = (e) => setMode('ALA', e.target);
        document.getElementById('tabLLL').onclick = (e) => setMode('LLL', e.target);
        document.getElementById('tabFREE').onclick = (e) => setMode('FREE', e.target);

        init();
    </script>
</body>
</html>
