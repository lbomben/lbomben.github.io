<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Simulazione Criteri di Congruenza</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #f1f5f9; touch-action: none; overflow: hidden; }
        canvas { 
            touch-action: none; 
            background: #ffffff; 
            cursor: crosshair;
            image-rendering: -webkit-optimize-contrast;
        }
        .active-tab { border-bottom: 4px solid #4f46e5; color: #4f46e5; background: #fff; }
    </style>
</head>
<body class="flex flex-col items-center min-h-screen p-2 md:p-4 font-sans">
    <a href="https://lbomben.github.io" class="mb-2 text-indigo-600 hover:underline text-sm">Homepage</a>

    <div class="max-w-5xl w-full bg-white rounded-xl shadow-2xl overflow-hidden flex flex-col border border-slate-200">
        <!-- Header -->
        <div class="bg-slate-900 p-4 text-white text-center">
            <h1 id="mainTitle" class="text-xl md:text-2xl font-bold">Primo Criterio (LAL)</h1>
            <p id="mainDesc" class="text-slate-400 text-xs md:text-sm italic">
                "Due triangoli sono congruenti se hanno uguali due lati e l'angolo tra essi compreso."
            </p>
        </div>

        <!-- Tabs -->
        <div class="flex border-b border-slate-200 bg-slate-50">
            <button id="tabLAL" class="flex-1 py-3 font-bold text-[10px] md:text-xs uppercase tracking-tighter active-tab">LAL</button>
            <button id="tabALA" class="flex-1 py-3 font-bold text-[10px] md:text-xs uppercase tracking-tighter text-slate-500">ALA</button>
            <button id="tabLLL" class="flex-1 py-3 font-bold text-[10px] md:text-xs uppercase tracking-tighter text-slate-500">LLL</button>
            <button id="tabFREE" class="flex-1 py-3 font-bold text-[10px] md:text-xs uppercase tracking-tighter text-amber-600 bg-amber-50/30">Libera ✨</button>
        </div>

        <!-- Dati Geometrici -->
        <div class="grid grid-cols-2 gap-px bg-slate-200 text-[10px] md:text-xs font-mono">
            <div class="p-2 bg-blue-50 text-blue-800 flex flex-col items-center">
                <span class="font-bold mb-1">TRIANGOLO ABC</span>
                <div id="stats1" class="text-center"></div>
            </div>
            <div class="p-2 bg-rose-50 text-rose-800 flex flex-col items-center">
                <span class="font-bold mb-1">TRIANGOLO DEF</span>
                <div id="stats2" class="text-center"></div>
            </div>
        </div>

        <!-- Canvas -->
        <div class="relative w-full bg-slate-100 p-1 flex justify-center items-center">
            <canvas id="geoCanvas" width="800" height="400" class="w-full h-auto max-w-full rounded shadow-inner"></canvas>
        </div>

        <!-- Controlli -->
        <div class="p-4 bg-white flex gap-2 justify-center border-t border-slate-100">
            <button id="overlapBtn" class="px-6 py-3 bg-indigo-600 text-white rounded-lg font-bold text-sm shadow-md active:scale-95 transition-all">
                Verifica Sovrapposizione
            </button>
            <button id="resetBtn" class="px-6 py-3 bg-slate-200 text-slate-700 rounded-lg font-bold text-sm hover:bg-slate-300 transition-all">
                Ruota DEF
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('geoCanvas');
        const ctx = canvas.getContext('2d');
        const overlapBtn = document.getElementById('overlapBtn');
        const resetBtn = document.getElementById('resetBtn');
        const stats1 = document.getElementById('stats1');
        const stats2 = document.getElementById('stats2');
        
        let pA, pB, pC; // Triangolo ABC
        let pD, pE, pF; // Triangolo DEF
        let mode = 'LAL';
        let rotation = Math.PI / 4;
        let overlapFactor = 0; 
        let isAnimating = false;
        let activePoint = null;
        let lastKnownDEF = null;

        function init() {
            pA = { x: 150, y: 300 };
            pB = { x: 300, y: 300 };
            pC = { x: 180, y: 150 };
            
            pD = { x: 500, y: 300 };
            syncDEF();
            draw();
        }

        function syncDEF() {
            if (mode === 'FREE' || isAnimating || overlapFactor > 0) return;

            const vAB = { x: pB.x - pA.x, y: pB.y - pA.y };
            const vAC = { x: pC.x - pA.x, y: pC.y - pA.y };

            const rot = (v, a) => ({
                x: v.x * Math.cos(a) - v.y * Math.sin(a),
                y: v.x * Math.sin(a) + v.y * Math.cos(a)
            });

            const rAB = rot(vAB, rotation);
            const rAC = rot(vAC, rotation);

            pE = { x: pD.x + rAB.x, y: pD.y + rAB.y };
            pF = { x: pD.x + rAC.x, y: pD.y + rAC.y };
        }

        function getDist(p1, p2) { return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2); }
        
        function getDeg(pCenter, p1, p2) {
            const a1 = Math.atan2(p1.y - pCenter.y, p1.x - pCenter.x);
            const a2 = Math.atan2(p2.y - pCenter.y, p2.x - pCenter.x);
            let angle = (a2 - a1) * 180 / Math.PI;
            if (angle < 0) angle += 360;
            return angle > 180 ? 360 - angle : angle;
        }

        // Funzione per disegnare i trattini di congruenza sui lati
        function drawSideMarker(p1, p2, color, count) {
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x) + Math.PI / 2;
            const len = 6;
            const gap = 3;

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            for (let i = 0; i < count; i++) {
                const shift = (i - (count - 1) / 2) * gap;
                const offsetX = Math.cos(angle - Math.PI / 2) * shift;
                const offsetY = Math.sin(angle - Math.PI / 2) * shift;
                ctx.beginPath();
                ctx.moveTo(midX + offsetX + Math.cos(angle) * len, midY + offsetY + Math.sin(angle) * len);
                ctx.lineTo(midX + offsetX - Math.cos(angle) * len, midY + offsetY - Math.sin(angle) * len);
                ctx.stroke();
            }
        }

        // Funzione per disegnare l'arco dell'angolo
        function drawAngleMarker(p, p1, p2, color, isHighlighted) {
            const a1 = Math.atan2(p1.y - p.y, p1.x - p.x);
            const a2 = Math.atan2(p2.y - p.y, p2.x - p.x);
            const r = 25;

            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.arc(p.x, p.y, r, a1, a2, Math.abs(a2 - a1) > Math.PI);
            ctx.closePath();
            ctx.fillStyle = color + (isHighlighted ? "40" : "10");
            ctx.fill();
            if (isHighlighted) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function drawTriangle(pts, color, labels, active) {
            const [p1, p2, p3] = pts;
            
            // Disegno area triangolo
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.closePath();
            ctx.fillStyle = color + "15";
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.lineWidth = active ? 3 : 1;
            ctx.stroke();

            // Marcatori di congruenza basati sulla modalità
            if (mode !== 'FREE') {
                const isLAL = mode === 'LAL';
                const isALA = mode === 'ALA';
                const isLLL = mode === 'LLL';

                // Lati
                if (isLAL || isALA || isLLL) drawSideMarker(p1, p2, color, 1); // AB / DE
                if (isLAL || isLLL) drawSideMarker(p1, p3, color, 2);          // AC / DF
                if (isLLL) drawSideMarker(p2, p3, color, 3);                   // BC / EF

                // Angoli
                drawAngleMarker(p1, p2, p3, color, isLAL || isALA); // Angolo in A / D
                drawAngleMarker(p2, p3, p1, color, isALA);          // Angolo in B / E
                drawAngleMarker(p3, p1, p2, color, false);          // Angolo in C / F (mai evidenziato dai criteri base)
            }

            // Vertici
            pts.forEach((p, i) => {
                const isDraggable = active && (labels[i] === 'A' || labels[i] === 'D' || mode === 'FREE');
                ctx.beginPath();
                ctx.arc(p.x, p.y, isDraggable ? 6 : 4, 0, Math.PI * 2);
                ctx.fillStyle = isDraggable ? "white" : color;
                ctx.fill();
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = "#1e293b";
                ctx.font = "bold 12px sans-serif";
                ctx.fillText(labels[i], p.x - 5, p.y - 12);
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!isAnimating && overlapFactor === 0) syncDEF();

            let renderDEF;
            if (overlapFactor > 0) {
                const start = lastKnownDEF || { D: pD, E: pE, F: pF };
                const lerp = (a, b, f) => a + (b - a) * f;
                renderDEF = [
                    { x: lerp(start.D.x, pA.x, overlapFactor), y: lerp(start.D.y, pA.y, overlapFactor) },
                    { x: lerp(start.E.x, pB.x, overlapFactor), y: lerp(start.E.y, pB.y, overlapFactor) },
                    { x: lerp(start.F.x, pC.x, overlapFactor), y: lerp(start.F.y, pC.y, overlapFactor) }
                ];
            } else {
                renderDEF = [pD, pE, pF];
            }

            drawTriangle([pA, pB, pC], "#2563eb", ["A", "B", "C"], overlapFactor === 0);
            drawTriangle(renderDEF, "#e11d48", ["D", "E", "F"], overlapFactor === 0);

            // Update Stats
            const fmt = (n) => (n/20).toFixed(1);
            stats1.innerHTML = `AB:${fmt(getDist(pA,pB))} AC:${fmt(getDist(pA,pC))} | A:${getDeg(pA,pB,pC).toFixed(0)}°`;
            stats2.innerHTML = `DE:${fmt(getDist(renderDEF[0],renderDEF[1]))} DF:${fmt(getDist(renderDEF[0],renderDEF[2]))} | D:${getDeg(renderDEF[0],renderDEF[1],renderDEF[2]).toFixed(0)}°`;
        }

        function animateOverlap(target) {
            if (isAnimating) return;
            isAnimating = true;
            lastKnownDEF = { D: {...pD}, E: {...pE}, F: {...pF} };
            
            const duration = 600;
            const startTime = performance.now();
            const startVal = overlapFactor;

            function step(now) {
                const elapsed = now - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const ease = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                overlapFactor = startVal + (target - startVal) * ease;
                draw();

                if (progress < 1) {
                    requestAnimationFrame(step);
                } else {
                    overlapFactor = target;
                    isAnimating = false;
                    if (overlapFactor === 0) lastKnownDEF = null;
                    overlapBtn.innerText = overlapFactor === 1 ? "Separa Triangoli" : "Verifica Sovrapposizione";
                    draw();
                }
            }
            requestAnimationFrame(step);
        }

        overlapBtn.onclick = () => animateOverlap(overlapFactor === 0 ? 1 : 0);
        resetBtn.onclick = () => {
            if (isAnimating || overlapFactor > 0) return;
            rotation = (Math.random() - 0.5) * Math.PI;
            draw();
        };

        function handleStart(e) {
            if (isAnimating || overlapFactor > 0) return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            const mx = x * (canvas.width / rect.width);
            const my = y * (canvas.height / rect.height);

            const pts = mode === 'FREE' ? [pA, pB, pC, pD, pE, pF] : [pA, pB, pC, pD];
            activePoint = pts.find(p => Math.hypot(p.x - mx, p.y - my) < 20);
        }

        function handleMove(e) {
            if (!activePoint) return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            activePoint.x = x * (canvas.width / rect.width);
            activePoint.y = y * (canvas.height / rect.height);
            draw();
        }

        canvas.onmousedown = handleStart;
        window.onmousemove = handleMove;
        window.onmouseup = () => activePoint = null;
        canvas.ontouchstart = (e) => { handleStart(e); e.preventDefault(); };
        canvas.ontouchmove = (e) => { handleMove(e); e.preventDefault(); };
        canvas.ontouchend = () => activePoint = null;

        function setMode(m, el) {
            mode = m;
            document.querySelectorAll('button').forEach(b => b.classList.remove('active-tab'));
            el.classList.add('active-tab');
            overlapFactor = 0;
            lastKnownDEF = null;
            
            if(m==='LAL'){ mainTitle.innerText="Primo Criterio (LAL)"; mainDesc.innerText='"Due triangoli sono congruenti se hanno uguali due lati e l\'angolo tra essi compreso."'; }
            if(m==='ALA'){ mainTitle.innerText="Secondo Criterio (ALA)"; mainDesc.innerText='"Due triangoli sono congruenti se hanno uguali un lato e i due angoli ad esso adiacenti."'; }
            if(m==='LLL'){ mainTitle.innerText="Terzo Criterio (LLL)"; mainDesc.innerText='"Due triangoli sono congruenti se hanno i tre lati rispettivamente uguali."'; }
            if(m==='FREE'){ mainTitle.innerText="Esplorazione Libera"; mainDesc.innerText='Manipola i vertici liberamente per testare la sovrapposizione.'; }
            
            draw();
        }

        document.getElementById('tabLAL').onclick = (e) => setMode('LAL', e.target);
        document.getElementById('tabALA').onclick = (e) => setMode('ALA', e.target);
        document.getElementById('tabLLL').onclick = (e) => setMode('LLL', e.target);
        document.getElementById('tabFREE').onclick = (e) => setMode('FREE', e.target);

        init();
    </script>
</body>
</html>
